JLabrad TODOs:

Server
- setting definitions
  - unpack arbitrarily complicated LabRAD types into structural Java types
  - also do introspection on return types and provide methods to convert from java back to LabRAD
- when an error happens inside a setting, include info in the returned message (which setting, etc.)
- message handlers (per context or global)
  - allow message handlers to be created declaratively, using annotations to set dispatch policy, etc.
- create server bean
- have connection bean fire RequestEvent
- handle context expiration messages
- think about using guice to inject default values of parameters, rather than overloading methods

Deployment
- how to deploy JLabrad to developers (just grab a jar)
- how to deploy apps for desktop (just double-click a jar)
- how to deploy apps with jnlp

Client
- provide a means to clear the server/setting cache
  - clear the cache automatically when a server disconnects

Data
- add get* and set* methods that do not check types for use with vectorization (these should be private)
- allow to get a subarray of a multidimensional array as a data object in its own right
  - just like a normal data object except for setting array size.  Maybe just disallow this?
- break up into interface and implementation

General
- allow to flatten data outside the network thread, so that exceptions do not kill the network thread (and for performance)
- try to write things as interfaces, rather than concrete types.
- implement connection object, server, client, etc. as beans (ala delphi API)
- easier way to get at the results of a packet call, rather than indexing into the result
  for example, each addRecord call returns a Future<Data> that can be queried separately
- write an interface for a server and then have an interface class autogenerated on the fly (what about packetization?)

Examples
- write some example clients and servers
